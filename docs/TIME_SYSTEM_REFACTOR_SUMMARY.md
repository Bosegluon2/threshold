# 时间系统重构总结

## 概述
根据用户要求，我们对任务系统的时间机制进行了重大重构，实现了更合理的时间跨度和事件分布。

## 主要修改

### 1. 时间粒度调整
- **之前**: `granularity = 10` (每回合10个小事件)
- **现在**: `granularity = 12` (每回合12个细粒度时间，每30分钟一个)
- **原因**: 更符合现实时间，一个step约6小时，细粒度时间30分钟更合理

### 2. 速度系统重构
- **之前**: 速度值在一个大回合中的总距离
- **现在**: 速度值在一个细粒度时间中的总距离
- **效果**: 玩家速度实际上是之前的12倍，更符合现实（之前需要3-4回合走20单位距离不合理）

### 3. 资源消耗机制
- **之前**: 在每个细粒度时间都消耗资源
- **现在**: 资源消耗只在step中调用一次，然后自动推算接下来的12个细粒度时间
- **实现**: 
  - `ConsumeResources()` 只在 `Step()` 中调用
  - 消耗率乘以12，因为一个step包含12个细粒度时间

### 4. 任务进度系统
- **之前**: 任务进度只在step中更新
- **现在**: 任务进度在每个细粒度时间都进行推演
- **实现**:
  - `ProcessGranularityTime()` 处理12个细粒度时间
  - `ProcessSingleGranularityStep()` 处理单个30分钟时间段
  - 每个细粒度时间都有机会触发事件和推进进度

### 5. 事件分布优化
- **遭遇战**: 每个细粒度时间都有机会，但概率降低到原来的1/12
- **资源获取**: 每个细粒度时间都有机会，但获取量是原来的1/12
- **任务进度**: 更均匀地分布在细粒度时间中

## 新的时间流程

```
GameManager.Step() (6小时)
├── MissionSimulator.Step() (6小时)
│   ├── ConsumeResources() (一次性消耗6小时的资源)
│   ├── ReplenishAgentResources() (一次性补充)
│   └── ProcessGranularityTime() (处理12个细粒度时间)
│       ├── 细粒度时间 1 (0:00-0:30)
│       │   ├── 检查遭遇战 (概率: EncounterChance/12)
│       │   ├── 资源获取 (概率: 15-50%)
│       │   └── 任务进度推进
│       ├── 细粒度时间 2 (0:30-1:00)
│       ├── ...
│       └── 细粒度时间 12 (5:30-6:00)
└── 其他系统更新
```

## 关键方法说明

### `Step(int currentGlobalTurn)`
- 主要的大回合步进方法
- 只调用一次资源消耗和补充
- 启动细粒度时间处理

### `ProcessGranularityTime()`
- 处理12个细粒度时间
- 防止重复调用
- 管理细粒度时间状态

### `ProcessSingleGranularityStep()`
- 处理单个30分钟时间段
- 计算具体时间（如 2:30）
- 触发各种事件和进度更新

### `ProcessResourceGathering()`
- 根据任务阶段和地点类型决定资源获取
- 每个细粒度时间都有机会
- 概率和数量更合理

## 优势

1. **时间更合理**: 6小时一个step，30分钟一个细粒度时间
2. **事件分布均匀**: 不再集中在step中，而是分布在细粒度时间中
3. **速度更真实**: 玩家移动速度更符合现实
4. **资源管理更好**: 消耗和获取更均匀，避免突然的大幅变化
5. **任务进度更平滑**: 每个30分钟都有进展，而不是突然跳跃

## 注意事项

1. **资源消耗**: 现在一次性消耗6小时的资源，确保资源配备充足
2. **事件概率**: 遭遇战等事件概率已调整，保持总体概率不变
3. **进度计算**: 任务进度现在基于细粒度时间，更精确
4. **性能**: 每个step需要处理12个细粒度时间，但逻辑更清晰

## 兼容性

- 保持了原有的API接口
- 任务创建和执行流程不变
- 只是内部的时间处理机制发生了变化
- 对现有代码影响最小
